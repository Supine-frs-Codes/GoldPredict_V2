#!/usr/bin/env python3
"""
GoldPredict V2.0 Áã¨Á´ãÂèØÊâßË°åÂêØÂä®Âô®
ÂåÖÂê´ÂÆåÊï¥ÁöÑÁ≥ªÁªü‰ª£Á†ÅÔºåÊó†ÈúÄÂ§ñÈÉ®Êñá‰ª∂‰æùËµñ
"""

import sys
import os
import threading
import time
import webbrowser
import json
from pathlib import Path
from datetime import datetime, timedelta
import logging

# ÂÜÖÂµåFlaskÂ∫îÁî®
from flask import Flask, render_template_string, jsonify, request, send_from_directory
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import requests

class GoldPredictV2:
    """GoldPredict V2.0 Ê†∏ÂøÉÁ≥ªÁªü"""
    
    def __init__(self):
        self.app = Flask(__name__)
        self.app.secret_key = 'goldpredict_v2_secret_key'
        self.model = None
        self.last_prediction = None
        self.system_status = {
            'running': True,
            'last_update': datetime.now(),
            'predictions_count': 0,
            'accuracy': 0.0
        }
        self.setup_routes()
        self.setup_logging()
        
    def setup_logging(self):
        """ËÆæÁΩÆÊó•Âøó"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
        
    def setup_routes(self):
        """ËÆæÁΩÆFlaskË∑ØÁî±"""
        
        @self.app.route('/')
        def index():
            return render_template_string(self.get_main_template())
        
        @self.app.route('/api/status')
        def api_status():
            return jsonify({
                'success': True,
                'status': self.system_status,
                'timestamp': datetime.now().isoformat()
            })
        
        @self.app.route('/api/predict', methods=['POST'])
        def api_predict():
            try:
                prediction = self.generate_prediction()
                return jsonify({
                    'success': True,
                    'prediction': prediction,
                    'timestamp': datetime.now().isoformat()
                })
            except Exception as e:
                return jsonify({
                    'success': False,
                    'error': str(e)
                }), 500
        
        @self.app.route('/api/train', methods=['POST'])
        def api_train():
            try:
                result = self.train_model()
                return jsonify({
                    'success': True,
                    'result': result,
                    'timestamp': datetime.now().isoformat()
                })
            except Exception as e:
                return jsonify({
                    'success': False,
                    'error': str(e)
                }), 500
    
    def get_sample_data(self):
        """ÁîüÊàêÁ§∫‰æãÊï∞ÊçÆ"""
        np.random.seed(42)
        dates = pd.date_range(start='2024-01-01', end='2024-12-31', freq='D')
        
        # ÁîüÊàêÊ®°ÊãüÈªÑÈáë‰ª∑Ê†ºÊï∞ÊçÆ
        base_price = 2000
        trend = np.linspace(0, 200, len(dates))  # ‰∏äÂçáË∂ãÂäø
        noise = np.random.normal(0, 20, len(dates))  # ÈöèÊú∫Ê≥¢Âä®
        seasonal = 10 * np.sin(2 * np.pi * np.arange(len(dates)) / 365)  # Â≠£ËäÇÊÄß
        
        prices = base_price + trend + noise + seasonal
        
        data = pd.DataFrame({
            'date': dates,
            'price': prices,
            'volume': np.random.randint(1000, 5000, len(dates)),
            'high': prices + np.random.uniform(5, 25, len(dates)),
            'low': prices - np.random.uniform(5, 25, len(dates)),
        })
        
        # Ê∑ªÂä†ÊäÄÊúØÊåáÊ†á
        data['sma_5'] = data['price'].rolling(5).mean()
        data['sma_20'] = data['price'].rolling(20).mean()
        data['volatility'] = data['price'].rolling(10).std()
        
        return data.dropna()
    
    def train_model(self):
        """ËÆ≠ÁªÉÈ¢ÑÊµãÊ®°Âûã"""
        self.logger.info("ÂºÄÂßãËÆ≠ÁªÉÊ®°Âûã...")
        
        # Ëé∑ÂèñÊï∞ÊçÆ
        data = self.get_sample_data()
        
        # ÂáÜÂ§áÁâπÂæÅ
        features = ['sma_5', 'sma_20', 'volatility', 'volume']
        X = data[features]
        y = data['price']
        
        # ÂàÜÂâ≤Êï∞ÊçÆ
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42
        )
        
        # ËÆ≠ÁªÉÊ®°Âûã
        self.model = RandomForestRegressor(n_estimators=100, random_state=42)
        self.model.fit(X_train, y_train)
        
        # ËØÑ‰º∞Ê®°Âûã
        y_pred = self.model.predict(X_test)
        mse = mean_squared_error(y_test, y_pred)
        r2 = r2_score(y_test, y_pred)
        
        self.system_status['accuracy'] = r2
        self.system_status['last_update'] = datetime.now()
        
        self.logger.info(f"Ê®°ÂûãËÆ≠ÁªÉÂÆåÊàê - R¬≤: {r2:.3f}, MSE: {mse:.2f}")
        
        return {
            'r2_score': r2,
            'mse': mse,
            'features': features,
            'training_samples': len(X_train),
            'test_samples': len(X_test)
        }
    
    def generate_prediction(self):
        """ÁîüÊàêÈ¢ÑÊµã"""
        if self.model is None:
            self.train_model()
        
        # Ëé∑ÂèñÊúÄÊñ∞Êï∞ÊçÆ
        data = self.get_sample_data()
        latest = data.iloc[-1]
        
        # ÂáÜÂ§áÈ¢ÑÊµãÁâπÂæÅ
        features = ['sma_5', 'sma_20', 'volatility', 'volume']
        X_pred = np.array([[latest[f] for f in features]])
        
        # ÁîüÊàêÈ¢ÑÊµã
        predicted_price = self.model.predict(X_pred)[0]
        current_price = latest['price']
        price_change = predicted_price - current_price
        price_change_pct = (price_change / current_price) * 100
        
        # ÁîüÊàê‰ø°Âè∑
        if price_change_pct > 2:
            signal = "Âº∫ÁÉàÁúãÊ∂®"
        elif price_change_pct > 0.5:
            signal = "ÁúãÊ∂®"
        elif price_change_pct > -0.5:
            signal = "Ê®™Áõò"
        elif price_change_pct > -2:
            signal = "ÁúãË∑å"
        else:
            signal = "Âº∫ÁÉàÁúãË∑å"
        
        prediction = {
            'current_price': round(current_price, 2),
            'predicted_price': round(predicted_price, 2),
            'price_change': round(price_change, 2),
            'price_change_pct': round(price_change_pct, 2),
            'signal': signal,
            'confidence': min(0.95, max(0.6, self.system_status['accuracy'])),
            'timestamp': datetime.now().isoformat()
        }
        
        self.last_prediction = prediction
        self.system_status['predictions_count'] += 1
        
        self.logger.info(f"ÁîüÊàêÈ¢ÑÊµã: {signal} ({price_change_pct:+.2f}%)")
        
        return prediction
    
    def get_main_template(self):
        """Ëé∑Âèñ‰∏ªÈ°µÈù¢Ê®°Êùø"""
        return '''
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèÜ GoldPredict V2.0 - Êô∫ËÉΩÈªÑÈáë‰ª∑Ê†ºÈ¢ÑÊµãÁ≥ªÁªü</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: 20px;
        }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .prediction-display {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 15px 0;
        }
        .price {
            font-size: 2em;
            font-weight: bold;
            color: #28a745;
            margin: 10px 0;
        }
        .signal {
            font-size: 1.5em;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            margin: 10px 0;
        }
        .signal.bullish { background: #d4edda; color: #155724; }
        .signal.bearish { background: #f8d7da; color: #721c24; }
        .signal.neutral { background: #fff3cd; color: #856404; }
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            margin: 5px;
        }
        .btn:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-online { background: #28a745; }
        .status-offline { background: #dc3545; }
        .footer {
            text-align: center;
            color: white;
            margin-top: 40px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÜ GoldPredict V2.0</h1>
            <p>Êô∫ËÉΩÈªÑÈáë‰ª∑Ê†ºÈ¢ÑÊµãÁ≥ªÁªü - Áã¨Á´ãÂèØÊâßË°åÁâàÊú¨</p>
        </div>
        
        <div class="dashboard">
            <div class="card">
                <h3>üìä ÂÆûÊó∂È¢ÑÊµã</h3>
                <div id="prediction-area">
                    <div class="prediction-display">
                        <div>ÂΩìÂâç‰ª∑Ê†º: <span id="current-price">Âä†ËΩΩ‰∏≠...</span></div>
                        <div class="price" id="predicted-price">$0.00</div>
                        <div class="signal neutral" id="signal">Á≠âÂæÖÈ¢ÑÊµã</div>
                        <div>ÁΩÆ‰ø°Â∫¶: <span id="confidence">0%</span></div>
                    </div>
                </div>
                <button class="btn" onclick="generatePrediction()">üîÆ ÁîüÊàêÈ¢ÑÊµã</button>
                <button class="btn" onclick="trainModel()">ü§ñ ËÆ≠ÁªÉÊ®°Âûã</button>
            </div>
            
            <div class="card">
                <h3>‚öôÔ∏è Á≥ªÁªüÁä∂ÊÄÅ</h3>
                <div>
                    <p><span class="status-indicator status-online"></span>Á≥ªÁªüÁä∂ÊÄÅ: <span id="system-status">ËøêË°å‰∏≠</span></p>
                    <p>È¢ÑÊµãÊ¨°Êï∞: <span id="predictions-count">0</span></p>
                    <p>Ê®°ÂûãÂáÜÁ°ÆÁéá: <span id="model-accuracy">0%</span></p>
                    <p>ÊúÄÂêéÊõ¥Êñ∞: <span id="last-update">Êú™Áü•</span></p>
                </div>
                <button class="btn" onclick="refreshStatus()">üîÑ Âà∑Êñ∞Áä∂ÊÄÅ</button>
            </div>
            
            <div class="card">
                <h3>üìà ÂäüËÉΩÁâπÊÄß</h3>
                <ul style="list-style: none; padding: 0;">
                    <li style="margin: 10px 0;">‚úÖ Êú∫Âô®Â≠¶‰π†È¢ÑÊµã</li>
                    <li style="margin: 10px 0;">‚úÖ ÂÆûÊó∂Êï∞ÊçÆÂàÜÊûê</li>
                    <li style="margin: 10px 0;">‚úÖ Êô∫ËÉΩ‰ø°Âè∑ÁîüÊàê</li>
                    <li style="margin: 10px 0;">‚úÖ Áã¨Á´ãÂèØÊâßË°å</li>
                    <li style="margin: 10px 0;">‚úÖ Êó†ÈúÄÂ§ñÈÉ®‰æùËµñ</li>
                </ul>
            </div>
        </div>
        
        <div class="footer">
            <p>üéâ GoldPredict V2.0 - ËÆ©Êô∫ËÉΩÈ¢ÑÊµãËß¶ÊâãÂèØÂèä</p>
            <p>ÁâàÊú¨: Áã¨Á´ãÂèØÊâßË°åÁâà | ÊûÑÂª∫Êó∂Èó¥: {{ build_time }}</p>
        </div>
    </div>

    <script>
        // Ëá™Âä®Âà∑Êñ∞Áä∂ÊÄÅ
        function refreshStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        document.getElementById('system-status').textContent = data.status.running ? 'ËøêË°å‰∏≠' : 'Â∑≤ÂÅúÊ≠¢';
                        document.getElementById('predictions-count').textContent = data.status.predictions_count;
                        document.getElementById('model-accuracy').textContent = (data.status.accuracy * 100).toFixed(1) + '%';
                        document.getElementById('last-update').textContent = new Date(data.status.last_update).toLocaleString();
                    }
                })
                .catch(error => console.error('Áä∂ÊÄÅÊõ¥Êñ∞Â§±Ë¥•:', error));
        }
        
        // ÁîüÊàêÈ¢ÑÊµã
        function generatePrediction() {
            fetch('/api/predict', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const pred = data.prediction;
                        document.getElementById('current-price').textContent = '$' + pred.current_price;
                        document.getElementById('predicted-price').textContent = '$' + pred.predicted_price;
                        document.getElementById('confidence').textContent = (pred.confidence * 100).toFixed(1) + '%';
                        
                        const signalElement = document.getElementById('signal');
                        signalElement.textContent = pred.signal;
                        signalElement.className = 'signal ' + getSignalClass(pred.signal);
                        
                        refreshStatus();
                    } else {
                        alert('È¢ÑÊµãÂ§±Ë¥•: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('È¢ÑÊµãÂ§±Ë¥•:', error);
                    alert('È¢ÑÊµãÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
                });
        }
        
        // ËÆ≠ÁªÉÊ®°Âûã
        function trainModel() {
            fetch('/api/train', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        alert('Ê®°ÂûãËÆ≠ÁªÉÂÆåÊàêÔºÅ\\nR¬≤ÂæóÂàÜ: ' + data.result.r2_score.toFixed(3));
                        refreshStatus();
                    } else {
                        alert('ËÆ≠ÁªÉÂ§±Ë¥•: ' + data.error);
                    }
                })
                .catch(error => {
                    console.error('ËÆ≠ÁªÉÂ§±Ë¥•:', error);
                    alert('ËÆ≠ÁªÉÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
                });
        }
        
        // Ëé∑Âèñ‰ø°Âè∑Ê†∑Âºè
        function getSignalClass(signal) {
            if (signal.includes('ÁúãÊ∂®')) return 'bullish';
            if (signal.includes('ÁúãË∑å')) return 'bearish';
            return 'neutral';
        }
        
        // È°µÈù¢Âä†ËΩΩÊó∂ÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            refreshStatus();
            // ÊØè30ÁßíËá™Âä®Âà∑Êñ∞Áä∂ÊÄÅ
            setInterval(refreshStatus, 30000);
        });
    </script>
</body>
</html>
        '''.replace('{{ build_time }}', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
    
    def run(self, host='127.0.0.1', port=5000, debug=False):
        """ËøêË°åFlaskÂ∫îÁî®"""
        self.logger.info(f"ÂêØÂä®GoldPredict V2.0ÊúçÂä°Âô®: http://{host}:{port}")
        self.app.run(host=host, port=port, debug=debug, use_reloader=False)

def print_banner():
    """ÊâìÂç∞ÂêØÂä®Ê®™ÂπÖ"""
    banner = """
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                    üèÜ GoldPredict V2.0                       ‚ïë
    ‚ïë                   Êô∫ËÉΩÈªÑÈáë‰ª∑Ê†ºÈ¢ÑÊµãÁ≥ªÁªü                        ‚ïë
    ‚ïë                     Áã¨Á´ãÂèØÊâßË°åÁâàÊú¨                           ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    print(banner)

def create_config_files():
    """ÂàõÂª∫ÈÖçÁΩÆÊñá‰ª∂"""
    config_dir = Path('config')
    config_dir.mkdir(exist_ok=True)
    
    # ÂàõÂª∫Âü∫Êú¨ÈÖçÁΩÆ
    config = {
        'system': {
            'name': 'GoldPredict V2.0',
            'version': '2.0.0-standalone',
            'port': 5000,
            'debug': False
        },
        'prediction': {
            'model_type': 'random_forest',
            'confidence_threshold': 0.7,
            'auto_retrain': True
        }
    }
    
    config_file = config_dir / 'config.json'
    with open(config_file, 'w', encoding='utf-8') as f:
        json.dump(config, f, indent=2, ensure_ascii=False)
    
    print(f"‚úÖ ÈÖçÁΩÆÊñá‰ª∂Â∑≤ÂàõÂª∫: {config_file}")

def main():
    """‰∏ªÂáΩÊï∞"""
    print_banner()
    
    print("üéØ GoldPredict V2.0 Áã¨Á´ãÂèØÊâßË°åÁâàÊú¨")
    print("=" * 50)
    print("1. ÂêØÂä®WebÊúçÂä° (Êé®Ëçê)")
    print("2. ÂàõÂª∫ÈÖçÁΩÆÊñá‰ª∂")
    print("0. ÈÄÄÂá∫")
    
    while True:
        try:
            choice = input("\nËØ∑ÈÄâÊã© (0-2): ").strip()
            
            if choice == '0':
                print("üëã ÂÜçËßÅÔºÅ")
                break
                
            elif choice == '1':
                print("\nüöÄ ÂêØÂä®GoldPredict V2.0 WebÊúçÂä°...")
                
                # ÂàõÂª∫Á≥ªÁªüÂÆû‰æã
                system = GoldPredictV2()
                
                # Âú®Êñ∞Á∫øÁ®ã‰∏≠ÊâìÂºÄÊµèËßàÂô®
                def open_browser():
                    time.sleep(2)
                    try:
                        webbrowser.open('http://localhost:5000')
                        print("üåê ÊµèËßàÂô®Â∑≤ÊâìÂºÄ: http://localhost:5000")
                    except:
                        print("‚ö†Ô∏è Êó†Ê≥ïËá™Âä®ÊâìÂºÄÊµèËßàÂô®ÔºåËØ∑ÊâãÂä®ËÆøÈóÆ: http://localhost:5000")
                
                browser_thread = threading.Thread(target=open_browser)
                browser_thread.daemon = True
                browser_thread.start()
                
                print("‚úÖ Á≥ªÁªüÂêØÂä®ÊàêÂäüÔºÅ")
                print("üåê ËÆøÈóÆÂú∞ÂùÄ: http://localhost:5000")
                print("üìä ÂäüËÉΩ: ÂÆûÊó∂È¢ÑÊµã„ÄÅÊ®°ÂûãËÆ≠ÁªÉ„ÄÅÁ≥ªÁªüÁõëÊéß")
                print("\nÊåâ Ctrl+C ÂÅúÊ≠¢ÊúçÂä°...")
                
                try:
                    # ËøêË°åFlaskÂ∫îÁî®
                    system.run(host='0.0.0.0', port=5000)
                except KeyboardInterrupt:
                    print("\n\nüõë ÊúçÂä°Â∑≤ÂÅúÊ≠¢")
                    break
                except Exception as e:
                    print(f"\n‚ùå ÊúçÂä°ËøêË°åÈîôËØØ: {e}")
                    break
                    
            elif choice == '2':
                create_config_files()
                
            else:
                print("‚ùå Êó†ÊïàÈÄâÊã©ÔºåËØ∑ÈáçËØï")
                
        except KeyboardInterrupt:
            print("\n\nüëã Áî®Êà∑‰∏≠Êñ≠ÔºåÈÄÄÂá∫Á®ãÂ∫è")
            break
        except Exception as e:
            print(f"‚ùå ÈîôËØØ: {e}")

if __name__ == "__main__":
    main()
